#!/usr/bin/env node
/**
 * Start Intake Script
 * Khởi tạo và quản lý intake session
 *
 * Outputs to: artifacts/runs/<run_id>/10_intake/
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');

// Import utils for artifact paths
const REPO_ROOT = (() => {
    let dir = __dirname;
    while (dir !== path.dirname(dir)) {
        if (fs.existsSync(path.join(dir, 'AGENTS.md'))) return dir;
        dir = path.dirname(dir);
    }
    return process.cwd();
})();

let utils;
try {
    utils = require(path.join(REPO_ROOT, '.agent/lib/utils.js'));
} catch (e) {
    // Fallback
    utils = {
        generateRunId: (slug) => {
            const now = new Date();
            const date = now.toISOString().slice(0, 10).replace(/-/g, '');
            const time = now.toTimeString().slice(0, 5).replace(':', '');
            const safeSlug = slug.toLowerCase().replace(/[^a-z0-9-]/g, '-').slice(0, 30);
            return `${date}_${time}_${safeSlug}`;
        },
        getArtifactPath: (runId, phase) => {
            const phases = { 'intake': '10_intake' };
            return path.join(REPO_ROOT, 'artifacts', 'runs', runId, phases[phase] || phase);
        },
        writeArtifact: (runId, phase, filename, content) => {
            const phasePath = utils.getArtifactPath(runId, phase);
            if (!fs.existsSync(phasePath)) {
                fs.mkdirSync(phasePath, { recursive: true });
            }
            const filePath = path.join(phasePath, filename);
            const data = typeof content === 'object' ? JSON.stringify(content, null, 2) : content;
            fs.writeFileSync(filePath, data, 'utf8');
            return filePath;
        }
    };
}

// Parse args first to get run_id
const parseArgs = () => {
    const args = process.argv.slice(2);
    const options = {};
    for (let i = 0; i < args.length; i++) {
        if (args[i] === '--quick') options.quick = true;
        else if (args[i] === '--name' && args[i + 1]) options.name = args[++i];
        else if (args[i] === '--run-id' && args[i + 1]) options.runId = args[++i];
        else if (args[i].startsWith('--')) {
            const key = args[i].slice(2);
            options[key] = args[i + 1] || true;
            if (args[i + 1] && !args[i + 1].startsWith('--')) i++;
        }
    }
    return options;
};

const options = parseArgs();
const RUN_ID = options.runId || process.env.RUN_ID || utils.generateRunId(options.name || 'intake');

// Intake template - Markdown
const createIntakeMarkdown = (data) => {
    const timestamp = new Date().toISOString();
    return `# Intake: ${data.projectName || 'Untitled Project'}

## Project Overview
- **Type**: ${data.projectType || 'TBD'}
- **Scale**: ${data.scale || 'TBD'}
- **Tech Stack**: ${data.techStack || 'TBD'}

## Target Users

### Primary User
- **Who**: ${data.primaryUser?.who || 'TBD'}
- **Pain Points**: ${data.primaryUser?.painPoints || 'TBD'}
- **Goals**: ${data.primaryUser?.goals || 'TBD'}

### Secondary Users
${data.secondaryUsers?.length ? data.secondaryUsers.map(u => `- ${u}`).join('\n') : '- None specified'}

## Features

### Must-Have (P0)
${data.mustHaveFeatures?.length ? data.mustHaveFeatures.map((f, i) => `${i + 1}. ${f}`).join('\n') : '- TBD'}

### Nice-to-Have (P1)
${data.niceToHaveFeatures?.length ? data.niceToHaveFeatures.map((f, i) => `${i + 1}. ${f}`).join('\n') : '- None specified'}

### Out of Scope
${data.outOfScope?.length ? data.outOfScope.map(s => `- ${s}`).join('\n') : '- Not defined yet'}

## Constraints
- **Timeline**: ${data.timeline || 'TBD'}
- **Budget**: ${data.budget || 'N/A'}
- **Tech Stack Requirements**: ${data.techRequirements || 'None'}
- **Performance Requirements**: ${data.performanceReqs || 'Standard'}

## Existing Context
- **Codebase**: ${data.existingCodebase || 'No'}
- **Design Files**: ${data.designFiles || 'No'}
- **Documentation**: ${data.existingDocs || 'No'}

## Integrations
${data.integrations?.length ? data.integrations.map(i => `- ${i}`).join('\n') : '- None specified'}

## Deployment
- **Environment**: ${data.deployEnv || 'TBD'}
- **Platform**: ${data.deployPlatform || 'TBD'}

## Open Questions
${data.openQuestions?.length ? data.openQuestions.map((q, i) => `${i + 1}. ${q}`).join('\n') : '- No open questions'}

## Next Steps
- [ ] Address open questions
- [ ] Proceed to Research phase
- [ ] Proceed to Spec phase

---
*Generated by Intake Skill | Run: ${RUN_ID} | Date: ${timestamp}*
`;
};

// Create JSON format for downstream consumption
const createIntakeJson = (data) => {
    return {
        version: '1.0',
        run_id: RUN_ID,
        timestamp: new Date().toISOString(),
        project: {
            name: data.projectName || 'Untitled',
            type: data.projectType || 'TBD',
            scale: data.scale || 'MVP'
        },
        users: {
            primary: data.primaryUser || { who: 'TBD', painPoints: 'TBD', goals: 'TBD' },
            secondary: data.secondaryUsers || []
        },
        scope: {
            mvp_features: data.mustHaveFeatures || [],
            nice_to_have: data.niceToHaveFeatures || [],
            out_of_scope: data.outOfScope || []
        },
        constraints: {
            timeline: data.timeline || 'TBD',
            budget: data.budget || 'N/A',
            tech_requirements: data.techRequirements || '',
            performance: data.performanceReqs || 'Standard'
        },
        context: {
            existing_codebase: data.existingCodebase || 'No',
            design_files: data.designFiles || 'No',
            documentation: data.existingDocs || 'No'
        },
        integrations: data.integrations || [],
        deployment: {
            environment: data.deployEnv || 'TBD',
            platform: data.deployPlatform || 'TBD'
        },
        open_questions: data.openQuestions || [],
        status: 'intake_ready'
    };
};

// Interactive mode
const startInteractiveIntake = async () => {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    const ask = (question) => new Promise((resolve) => {
        rl.question(question, (answer) => resolve(answer.trim()));
    });

    console.log('\n========================================');
    console.log('   INTAKE SESSION - Thu thập yêu cầu');
    console.log('========================================\n');
    console.log(`Run ID: ${RUN_ID}`);
    console.log('Gõ "skip" để bỏ qua câu hỏi');
    console.log('Gõ "quit" để thoát và lưu\n');

    const data = {
        mustHaveFeatures: [],
        niceToHaveFeatures: [],
        outOfScope: [],
        secondaryUsers: [],
        integrations: [],
        openQuestions: []
    };

    try {
        // Project basics
        data.projectName = await ask('1. Tên dự án: ');
        if (data.projectName === 'quit') throw new Error('User quit');

        data.projectType = await ask('2. Loại dự án (Web App/Mobile/API/CLI/Library/Desktop): ');
        data.scale = await ask('3. Quy mô (MVP/Product/Enterprise): ');
        data.techStack = await ask('4. Tech stack mong muốn (hoặc skip): ');

        // Users
        console.log('\n--- TARGET USERS ---');
        const primaryWho = await ask('5. Người dùng chính là ai? ');
        const primaryPain = await ask('6. Họ gặp vấn đề gì? ');
        const primaryGoal = await ask('7. Họ muốn đạt được gì? ');

        data.primaryUser = {
            who: primaryWho !== 'skip' ? primaryWho : 'TBD',
            painPoints: primaryPain !== 'skip' ? primaryPain : 'TBD',
            goals: primaryGoal !== 'skip' ? primaryGoal : 'TBD'
        };

        // Features
        console.log('\n--- FEATURES ---');
        console.log('Nhập từng feature, gõ "done" khi xong');

        console.log('\nMust-have features (P0):');
        let input = '';
        while ((input = await ask('  - ')) !== 'done' && input !== 'quit') {
            if (input && input !== 'skip') data.mustHaveFeatures.push(input);
        }

        console.log('\nNice-to-have features (P1):');
        while ((input = await ask('  - ')) !== 'done' && input !== 'quit') {
            if (input && input !== 'skip') data.niceToHaveFeatures.push(input);
        }

        // Constraints
        console.log('\n--- CONSTRAINTS ---');
        data.timeline = await ask('8. Timeline/Deadline: ');
        data.budget = await ask('9. Budget (hoặc skip): ');
        data.techRequirements = await ask('10. Tech requirements bắt buộc: ');

        // Existing context
        console.log('\n--- EXISTING CONTEXT ---');
        data.existingCodebase = await ask('11. Có code sẵn không? (Yes/No + chi tiết): ');
        data.designFiles = await ask('12. Có design files không? (Yes/No + chi tiết): ');

        // Deployment
        console.log('\n--- DEPLOYMENT ---');
        data.deployPlatform = await ask('13. Deploy ở đâu? (AWS/GCP/Vercel/etc): ');

        // Open questions
        console.log('\n--- OPEN QUESTIONS ---');
        console.log('Còn câu hỏi nào cần clarify? (gõ "done" khi xong)');
        while ((input = await ask('  ? ')) !== 'done' && input !== 'quit') {
            if (input && input !== 'skip') data.openQuestions.push(input);
        }

    } catch (e) {
        console.log('\n[!] Session ended early');
    }

    rl.close();
    return data;
};

// Quick mode - from arguments
const quickIntake = () => {
    return {
        projectName: options.name || 'Quick Project',
        projectType: options.type || 'TBD',
        scale: options.scale || 'MVP',
        techStack: options.tech || 'TBD',
        mustHaveFeatures: options.features ? options.features.split(',') : [],
        niceToHaveFeatures: [],
        outOfScope: [],
        secondaryUsers: [],
        integrations: [],
        openQuestions: ['Cần clarify thêm chi tiết'],
        primaryUser: { who: 'TBD', painPoints: 'TBD', goals: 'TBD' }
    };
};

// Main
const main = async () => {
    let data;

    if (options.quick) {
        data = quickIntake();
    } else {
        data = await startInteractiveIntake();
    }

    // Write artifacts
    const mdPath = utils.writeArtifact(RUN_ID, 'intake', 'intake.summary.md', createIntakeMarkdown(data));
    const jsonPath = utils.writeArtifact(RUN_ID, 'intake', 'intake.json', createIntakeJson(data));

    console.log(`\n[OK] Intake saved:`);
    console.log(`  - ${mdPath}`);
    console.log(`  - ${jsonPath}`);
    console.log(`\nRun ID: ${RUN_ID}`);
    console.log('\nNext steps:');
    console.log(`  1. Review intake files`);
    console.log(`  2. npx aat research --run-id ${RUN_ID}`);
    console.log(`  3. npx aat spec --run-id ${RUN_ID}`);
};

main();
